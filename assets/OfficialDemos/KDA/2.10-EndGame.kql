#connect cluster('kvc43f0ee6600e24ef2b0e.southcentralus').database('KustoDetectiveAgency')

// End Game

.execute database script <|
.create table KuandaLogs (Timestamp:datetime, DetectiveId:string, Message:string)
.ingest async into table KuandaLogs (@'https://kustodetectiveagency.blob.core.windows.net/kda2c10adminlogs/log_00000.csv.gz')
.ingest async into table KuandaLogs (@'https://kustodetectiveagency.blob.core.windows.net/kda2c10adminlogs/log_00001.csv.gz')
.ingest into table KuandaLogs (@'https://kustodetectiveagency.blob.core.windows.net/kda2c10adminlogs/log_00002.csv.gz')



// hint 1
// All traces look alike, isn't it? Or... indeed - it isn't. 
// Anything exceptional catch your eye?

// hint 2
// Did you get what are the trojan's intentions?
// The key to the solution may be spread between the lines.

// hint 3
// Can you craft your final answer so it will fall between the cracks of the Kuanda's bitter defense?


KuandaLogs
| take 10


// partition
// https://learn.microsoft.com/azure/data-explorer/kusto/query/partitionoperator
// calc the time between events per detective.
KuandaLogs
| where DetectiveId endswith '11' // Just a sample of the data.
| partition hint.strategy=native by DetectiveId // has lots of unique keys
(
    order by Timestamp asc 
    | extend Diff = Timestamp - prev(Timestamp)
)

// scan
// https://learn.microsoft.com/azure/data-explorer/kusto/query/scan-operator
// ie. find the 1st activity within 10m of login event.
KuandaLogs
| where DetectiveId endswith '11' // Just a sample of the data.
| partition hint.strategy=native by DetectiveId
(
    order by Timestamp asc 
    | scan declare(FirstActivity:string, LoginTime:datetime) with (
        step start output=none: Message has 'User entered the system' => LoginTime=Timestamp; 
        step s2:
            Timestamp - start.LoginTime < 10min and Message !has 'User entered the system' 
            =>  FirstActivity = Message, LoginTime = start.LoginTime;
    )
    | project DetectiveId, LoginTime, FirstActivityTimestamp=Timestamp,  FirstActivity
)


// calc detective working 'sessions'
// a 'session' starts when user 'enters the system' or encounters a 'user session reset'
// 'session' ends after 10m pass.
KuandaLogs
| where DetectiveId endswith '11' // Just a sample of the data.
| partition hint.strategy=native by DetectiveId
(
    order by Timestamp asc 
     | scan with_match_id=id  declare(StartTime:datetime, EndTime:datetime) with (
        step start output=none: 
			Message has 'User entered the system' or Message has 'User session reset' => StartTime = Timestamp;
        step completed output=last:
			(Timestamp-start.StartTime > 10min) => 
			StartTime = start.StartTime, EndTime = Timestamp;
    )
    | order by id asc, Timestamp asc
    | extend SessionDuration = EndTime - StartTime
)
// The 'scan' operator operates by running over ordered event records (as indicated by "order by Timestamp asc") 
// and employs programmed sequence scanning logic with steps. Each step contains a predicate (condition) and 
// may include several assignments that update the 'scan's state. This state is defined using the "declare()" clause and 
// proves extremely useful for preserving calculation results and sharing them between steps. 
// It's not limited to primitive types and can include dynamic arrays and dynamic property bags as well

// Good luck, we're count()ing on you.

let Traces = datatable(EventText: string)
    [
    "Event: NotifySliceRelease (resourceName=PipelineScheduler, totalSlices=27, sliceNumber=23, lockTime=02/17/2016 08:40:01, releaseTime=02/17/2016 08:40:01, previousLockTime=02/17/2016 08:39:01)",
    "Event: NotifySliceRelease (resourceName=PipelineScheduler, totalSlices=27, sliceNumber=15, lockTime=02/17/2016 08:40:00, releaseTime=02/17/2016 08:40:00, previousLockTime=02/17/2016 08:39:00)",
    "Event: NotifySliceRelease (resourceName=PipelineScheduler, totalSlices=27, sliceNumber=20, lockTime=02/17/2016 08:40:01, releaseTime=02/17/2016 08:40:01, previousLockTime=02/17/2016 08:39:01)",
    "Event: NotifySliceRelease (resourceName=PipelineScheduler, totalSlices=27, sliceNumber=22, lockTime=02/17/2016 08:41:01, releaseTime=02/17/2016 08:41:00, previousLockTime=02/17/2016 08:40:01)",
    "Event: NotifySliceRelease (resourceName=PipelineScheduler, totalSlices=27, sliceNumber=16, lockTime=02/17/2016 08:41:00, releaseTime=02/17/2016 08:41:00, previousLockTime=02/17/2016 08:40:00)"
];
Traces  
| parse EventText with * "resourceName=" resourceName ", totalSlices=" totalSlices: long * "sliceNumber=" sliceNumber: long * "lockTime=" lockTime ", releaseTime=" releaseTime: date "," * "previousLockTime=" previousLockTime: date ")" *  
| project resourceName, totalSlices, sliceNumber, lockTime, releaseTime, previousLockTime


KuandaLogs
| where Message has 'encryption'
| parse Message with * "Operation id=" operationId:string 
| take 1000
//2023-09-12T23:53:30Z	kvc727bffe9221c465a592	Sending an encrypted message, will use Dekrypt(@'tBhku8uLuQULuDTou8udZDuduBiluQikuQiku4ERh4vV5\LEmeI9RGZYIXiCr[08ZBh[5e0e0DU6u848ZQ575DoyuXI95tyBR\16I6ijhO48ROY\0nv7I\16hO1l5[TyIP2Em\S9ROWj0tyBhO4l0KvB0tyUrtyChP2g0tA9ROJ9n[1Vme2VFXvh5GvkcnverGZgrtyChp==', strcat_array(<active-user-encryption-tokens>, '')) for decoding.

KuandaLogs
| where Message has 'decoding'
| parse Message with * "Operation id=" operationId:string 
| take 1000
// 192 rows

// kvc2ac0c1fdbe22ec157c8, 2023-09-08T02:28:30Z
// Sending an encrypted message, will use Dekrypt(@'mbNYouohoQThoQKpoQNeou5eobUqoQUYoQUYozJ\N[hO9m0T9nZbVPjvVPN5ciR4\PjqVm159mX5VPjDMENqsgX51vO3MgY5\vp5MPRb\HZhFm\D9PlCNWAOcgZbVPjvVPjbNBl3N[zSlHZYciAuVPSbMEjbNBl3NWzvMvCTNBlkVPSCNBS0cElCMnZk9mI4cD[=', strcat_array(<active-user-encryption-tokens>, '')) for decoding.

KuandaLogs
| where DetectiveId =='kvc2ac0c1fdbe22ec157c8'
| order by Timestamp asc

Operation id=7f94cf8292d874cf started ('CaseAssigned'). Captured user encryption token: 'vjma'.
Dekrypt(@'mbNYouohoQThoQKpoQNeou5eobUqoQUYoQUYozJ\N[hO9m0T9nZbVPjvVPN5ciR4\PjqVm159mX5VPjDMENqsgX51vO3MgY5\vp5MPRb\HZhFm\D9PlCNWAOcgZbVPjvVPjbNBl3N[zSlHZYciAuVPSbMEjbNBl3NWzvMvCTNBlkVPSCNBS0cElCMnZk9mI4cD[=', strcat_array(<active-user-encryption-tokens>, '')) for decoding.

print Message=@"mbNYouohoQThoQKpoQNeou5eobUqoQUYoQUYozJ\N[hO9m0T9nZbVPjvVPN5ciR4\PjqVm159mX5VPjDMENqsgX51vO3MgY5\vp5MPRb\HZhFm\D9PlCNWAOcgZbVPjvVPjbNBl3N[zSlHZYciAuVPSbMEjbNBl3NWzvMvCTNBlkVPSCNBS0cElCMnZk9mI4cD[=", Key=strcat('qehswdmpvjma')
| invoke Dekrypt()


// now I need all the enkrypted messages by DetectiveId and their active keys upto the enk msg.
// partition & scan

let affected = KuandaLogs | where Message has 'Dekrypt' | distinct DetectiveId;
KuandaLogs
| where DetectiveId in (affected)
| partition hint.strategy=native by DetectiveId // has lots of unique keys
(
    order by Timestamp asc 
    | extend Diff = Timestamp - prev(Timestamp)
)
| where Diff <= timespan(10m)
| parse Message with * "@'" kryptmsg:string "'" *


let affected = KuandaLogs | where Message has 'Dekrypt' | distinct DetectiveId;
KuandaLogs
| where DetectiveId in (affected)
| partition hint.strategy=native by DetectiveId
(
    order by Timestamp asc 
     | scan with_match_id=id  declare(StartTime:datetime, EndTime:datetime) with (
        step start output=none: 
			Message has 'Dekrypt' or Message has 'User session reset' => StartTime = Timestamp;
        step completed output=last:
			(Timestamp-start.StartTime > 10min) => 
			StartTime = start.StartTime, EndTime = Timestamp;
    )
    | order by id asc, Timestamp asc
    | extend SessionDuration = EndTime - StartTime
)
